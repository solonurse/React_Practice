{"ast":null,"code":"'use strict';\n\nconst escapeStringRegexp = require('escape-string-regexp');\nconst cwd = typeof process === 'object' && process && typeof process.cwd === 'function' ? process.cwd() : '.';\nconst natives = [].concat(require('module').builtinModules, 'bootstrap_node', 'node').map(n => new RegExp(`(?:\\\\((?:node:)?${n}(?:\\\\.js)?:\\\\d+:\\\\d+\\\\)$|^\\\\s*at (?:node:)?${n}(?:\\\\.js)?:\\\\d+:\\\\d+$)`));\nnatives.push(/\\((?:node:)?internal\\/[^:]+:\\d+:\\d+\\)$/, /\\s*at (?:node:)?internal\\/[^:]+:\\d+:\\d+$/, /\\/\\.node-spawn-wrap-\\w+-\\w+\\/node:\\d+:\\d+\\)?$/);\nclass StackUtils {\n  constructor(opts) {\n    opts = {\n      ignoredPackages: [],\n      ...opts\n    };\n    if ('internals' in opts === false) {\n      opts.internals = StackUtils.nodeInternals();\n    }\n    if ('cwd' in opts === false) {\n      opts.cwd = cwd;\n    }\n    this._cwd = opts.cwd.replace(/\\\\/g, '/');\n    this._internals = [].concat(opts.internals, ignoredPackagesRegExp(opts.ignoredPackages));\n    this._wrapCallSite = opts.wrapCallSite || false;\n  }\n  static nodeInternals() {\n    return [...natives];\n  }\n  clean(stack, indent = 0) {\n    indent = ' '.repeat(indent);\n    if (!Array.isArray(stack)) {\n      stack = stack.split('\\n');\n    }\n    if (!/^\\s*at /.test(stack[0]) && /^\\s*at /.test(stack[1])) {\n      stack = stack.slice(1);\n    }\n    let outdent = false;\n    let lastNonAtLine = null;\n    const result = [];\n    stack.forEach(st => {\n      st = st.replace(/\\\\/g, '/');\n      if (this._internals.some(internal => internal.test(st))) {\n        return;\n      }\n      const isAtLine = /^\\s*at /.test(st);\n      if (outdent) {\n        st = st.trimEnd().replace(/^(\\s+)at /, '$1');\n      } else {\n        st = st.trim();\n        if (isAtLine) {\n          st = st.slice(3);\n        }\n      }\n      st = st.replace(`${this._cwd}/`, '');\n      if (st) {\n        if (isAtLine) {\n          if (lastNonAtLine) {\n            result.push(lastNonAtLine);\n            lastNonAtLine = null;\n          }\n          result.push(st);\n        } else {\n          outdent = true;\n          lastNonAtLine = st;\n        }\n      }\n    });\n    return result.map(line => `${indent}${line}\\n`).join('');\n  }\n  captureString(limit, fn = this.captureString) {\n    if (typeof limit === 'function') {\n      fn = limit;\n      limit = Infinity;\n    }\n    const {\n      stackTraceLimit\n    } = Error;\n    if (limit) {\n      Error.stackTraceLimit = limit;\n    }\n    const obj = {};\n    Error.captureStackTrace(obj, fn);\n    const {\n      stack\n    } = obj;\n    Error.stackTraceLimit = stackTraceLimit;\n    return this.clean(stack);\n  }\n  capture(limit, fn = this.capture) {\n    if (typeof limit === 'function') {\n      fn = limit;\n      limit = Infinity;\n    }\n    const {\n      prepareStackTrace,\n      stackTraceLimit\n    } = Error;\n    Error.prepareStackTrace = (obj, site) => {\n      if (this._wrapCallSite) {\n        return site.map(this._wrapCallSite);\n      }\n      return site;\n    };\n    if (limit) {\n      Error.stackTraceLimit = limit;\n    }\n    const obj = {};\n    Error.captureStackTrace(obj, fn);\n    const {\n      stack\n    } = obj;\n    Object.assign(Error, {\n      prepareStackTrace,\n      stackTraceLimit\n    });\n    return stack;\n  }\n  at(fn = this.at) {\n    const [site] = this.capture(1, fn);\n    if (!site) {\n      return {};\n    }\n    const res = {\n      line: site.getLineNumber(),\n      column: site.getColumnNumber()\n    };\n    setFile(res, site.getFileName(), this._cwd);\n    if (site.isConstructor()) {\n      Object.defineProperty(res, 'constructor', {\n        value: true,\n        configurable: true\n      });\n    }\n    if (site.isEval()) {\n      res.evalOrigin = site.getEvalOrigin();\n    }\n\n    // Node v10 stopped with the isNative() on callsites, apparently\n    /* istanbul ignore next */\n    if (site.isNative()) {\n      res.native = true;\n    }\n    let typename;\n    try {\n      typename = site.getTypeName();\n    } catch (_) {}\n    if (typename && typename !== 'Object' && typename !== '[object Object]') {\n      res.type = typename;\n    }\n    const fname = site.getFunctionName();\n    if (fname) {\n      res.function = fname;\n    }\n    const meth = site.getMethodName();\n    if (meth && fname !== meth) {\n      res.method = meth;\n    }\n    return res;\n  }\n  parseLine(line) {\n    const match = line && line.match(re);\n    if (!match) {\n      return null;\n    }\n    const ctor = match[1] === 'new';\n    let fname = match[2];\n    const evalOrigin = match[3];\n    const evalFile = match[4];\n    const evalLine = Number(match[5]);\n    const evalCol = Number(match[6]);\n    let file = match[7];\n    const lnum = match[8];\n    const col = match[9];\n    const native = match[10] === 'native';\n    const closeParen = match[11] === ')';\n    let method;\n    const res = {};\n    if (lnum) {\n      res.line = Number(lnum);\n    }\n    if (col) {\n      res.column = Number(col);\n    }\n    if (closeParen && file) {\n      // make sure parens are balanced\n      // if we have a file like \"asdf) [as foo] (xyz.js\", then odds are\n      // that the fname should be += \" (asdf) [as foo]\" and the file\n      // should be just \"xyz.js\"\n      // walk backwards from the end to find the last unbalanced (\n      let closes = 0;\n      for (let i = file.length - 1; i > 0; i--) {\n        if (file.charAt(i) === ')') {\n          closes++;\n        } else if (file.charAt(i) === '(' && file.charAt(i - 1) === ' ') {\n          closes--;\n          if (closes === -1 && file.charAt(i - 1) === ' ') {\n            const before = file.slice(0, i - 1);\n            const after = file.slice(i + 1);\n            file = after;\n            fname += ` (${before}`;\n            break;\n          }\n        }\n      }\n    }\n    if (fname) {\n      const methodMatch = fname.match(methodRe);\n      if (methodMatch) {\n        fname = methodMatch[1];\n        method = methodMatch[2];\n      }\n    }\n    setFile(res, file, this._cwd);\n    if (ctor) {\n      Object.defineProperty(res, 'constructor', {\n        value: true,\n        configurable: true\n      });\n    }\n    if (evalOrigin) {\n      res.evalOrigin = evalOrigin;\n      res.evalLine = evalLine;\n      res.evalColumn = evalCol;\n      res.evalFile = evalFile && evalFile.replace(/\\\\/g, '/');\n    }\n    if (native) {\n      res.native = true;\n    }\n    if (fname) {\n      res.function = fname;\n    }\n    if (method && fname !== method) {\n      res.method = method;\n    }\n    return res;\n  }\n}\nfunction setFile(result, filename, cwd) {\n  if (filename) {\n    filename = filename.replace(/\\\\/g, '/');\n    if (filename.startsWith(`${cwd}/`)) {\n      filename = filename.slice(cwd.length + 1);\n    }\n    result.file = filename;\n  }\n}\nfunction ignoredPackagesRegExp(ignoredPackages) {\n  if (ignoredPackages.length === 0) {\n    return [];\n  }\n  const packages = ignoredPackages.map(mod => escapeStringRegexp(mod));\n  return new RegExp(`[\\/\\\\\\\\]node_modules[\\/\\\\\\\\](?:${packages.join('|')})[\\/\\\\\\\\][^:]+:\\\\d+:\\\\d+`);\n}\nconst re = new RegExp('^' +\n// Sometimes we strip out the '    at' because it's noisy\n'(?:\\\\s*at )?' +\n// $1 = ctor if 'new'\n'(?:(new) )?' +\n// $2 = function name (can be literally anything)\n// May contain method at the end as [as xyz]\n'(?:(.*?) \\\\()?' +\n// (eval at <anonymous> (file.js:1:1),\n// $3 = eval origin\n// $4:$5:$6 are eval file/line/col, but not normally reported\n'(?:eval at ([^ ]+) \\\\((.+?):(\\\\d+):(\\\\d+)\\\\), )?' +\n// file:line:col\n// $7:$8:$9\n// $10 = 'native' if native\n'(?:(.+?):(\\\\d+):(\\\\d+)|(native))' +\n// maybe close the paren, then end\n// if $11 is ), then we only allow balanced parens in the filename\n// any imbalance is placed on the fname.  This is a heuristic, and\n// bound to be incorrect in some edge cases.  The bet is that\n// having weird characters in method names is more common than\n// having weird characters in filenames, which seems reasonable.\n'(\\\\)?)$');\nconst methodRe = /^(.*?) \\[as (.*?)\\]$/;\nmodule.exports = StackUtils;","map":{"version":3,"names":["escapeStringRegexp","require","cwd","process","natives","concat","builtinModules","map","n","RegExp","push","StackUtils","constructor","opts","ignoredPackages","internals","nodeInternals","_cwd","replace","_internals","ignoredPackagesRegExp","_wrapCallSite","wrapCallSite","clean","stack","indent","repeat","Array","isArray","split","test","slice","outdent","lastNonAtLine","result","forEach","st","some","internal","isAtLine","trimEnd","trim","line","join","captureString","limit","fn","Infinity","stackTraceLimit","Error","obj","captureStackTrace","capture","prepareStackTrace","site","Object","assign","at","res","getLineNumber","column","getColumnNumber","setFile","getFileName","isConstructor","defineProperty","value","configurable","isEval","evalOrigin","getEvalOrigin","isNative","native","typename","getTypeName","_","type","fname","getFunctionName","function","meth","getMethodName","method","parseLine","match","re","ctor","evalFile","evalLine","Number","evalCol","file","lnum","col","closeParen","closes","i","length","charAt","before","after","methodMatch","methodRe","evalColumn","filename","startsWith","packages","mod","module","exports"],"sources":["/Users/nakanoshunsuke/Desktop/react-guide-material/07_styling_component/node_modules/stack-utils/index.js"],"sourcesContent":["'use strict';\n\nconst escapeStringRegexp = require('escape-string-regexp');\n\nconst cwd = typeof process === 'object' && process && typeof process.cwd === 'function'\n  ? process.cwd()\n  : '.'\n\nconst natives = [].concat(\n  require('module').builtinModules,\n  'bootstrap_node',\n  'node',\n).map(n => new RegExp(`(?:\\\\((?:node:)?${n}(?:\\\\.js)?:\\\\d+:\\\\d+\\\\)$|^\\\\s*at (?:node:)?${n}(?:\\\\.js)?:\\\\d+:\\\\d+$)`));\n\nnatives.push(\n  /\\((?:node:)?internal\\/[^:]+:\\d+:\\d+\\)$/,\n  /\\s*at (?:node:)?internal\\/[^:]+:\\d+:\\d+$/,\n  /\\/\\.node-spawn-wrap-\\w+-\\w+\\/node:\\d+:\\d+\\)?$/\n);\n\nclass StackUtils {\n  constructor (opts) {\n    opts = {\n      ignoredPackages: [],\n      ...opts\n    };\n\n    if ('internals' in opts === false) {\n      opts.internals = StackUtils.nodeInternals();\n    }\n\n    if ('cwd' in opts === false) {\n      opts.cwd = cwd\n    }\n\n    this._cwd = opts.cwd.replace(/\\\\/g, '/');\n    this._internals = [].concat(\n      opts.internals,\n      ignoredPackagesRegExp(opts.ignoredPackages)\n    );\n\n    this._wrapCallSite = opts.wrapCallSite || false;\n  }\n\n  static nodeInternals () {\n    return [...natives];\n  }\n\n  clean (stack, indent = 0) {\n    indent = ' '.repeat(indent);\n\n    if (!Array.isArray(stack)) {\n      stack = stack.split('\\n');\n    }\n\n    if (!(/^\\s*at /.test(stack[0])) && (/^\\s*at /.test(stack[1]))) {\n      stack = stack.slice(1);\n    }\n\n    let outdent = false;\n    let lastNonAtLine = null;\n    const result = [];\n\n    stack.forEach(st => {\n      st = st.replace(/\\\\/g, '/');\n\n      if (this._internals.some(internal => internal.test(st))) {\n        return;\n      }\n\n      const isAtLine = /^\\s*at /.test(st);\n\n      if (outdent) {\n        st = st.trimEnd().replace(/^(\\s+)at /, '$1');\n      } else {\n        st = st.trim();\n        if (isAtLine) {\n          st = st.slice(3);\n        }\n      }\n\n      st = st.replace(`${this._cwd}/`, '');\n\n      if (st) {\n        if (isAtLine) {\n          if (lastNonAtLine) {\n            result.push(lastNonAtLine);\n            lastNonAtLine = null;\n          }\n\n          result.push(st);\n        } else {\n          outdent = true;\n          lastNonAtLine = st;\n        }\n      }\n    });\n\n    return result.map(line => `${indent}${line}\\n`).join('');\n  }\n\n  captureString (limit, fn = this.captureString) {\n    if (typeof limit === 'function') {\n      fn = limit;\n      limit = Infinity;\n    }\n\n    const {stackTraceLimit} = Error;\n    if (limit) {\n      Error.stackTraceLimit = limit;\n    }\n\n    const obj = {};\n\n    Error.captureStackTrace(obj, fn);\n    const {stack} = obj;\n    Error.stackTraceLimit = stackTraceLimit;\n\n    return this.clean(stack);\n  }\n\n  capture (limit, fn = this.capture) {\n    if (typeof limit === 'function') {\n      fn = limit;\n      limit = Infinity;\n    }\n\n    const {prepareStackTrace, stackTraceLimit} = Error;\n    Error.prepareStackTrace = (obj, site) => {\n      if (this._wrapCallSite) {\n        return site.map(this._wrapCallSite);\n      }\n\n      return site;\n    };\n\n    if (limit) {\n      Error.stackTraceLimit = limit;\n    }\n\n    const obj = {};\n    Error.captureStackTrace(obj, fn);\n    const { stack } = obj;\n    Object.assign(Error, {prepareStackTrace, stackTraceLimit});\n\n    return stack;\n  }\n\n  at (fn = this.at) {\n    const [site] = this.capture(1, fn);\n\n    if (!site) {\n      return {};\n    }\n\n    const res = {\n      line: site.getLineNumber(),\n      column: site.getColumnNumber()\n    };\n\n    setFile(res, site.getFileName(), this._cwd);\n\n    if (site.isConstructor()) {\n      Object.defineProperty(res, 'constructor', {\n        value: true,\n        configurable: true,\n      });\n    }\n\n    if (site.isEval()) {\n      res.evalOrigin = site.getEvalOrigin();\n    }\n\n    // Node v10 stopped with the isNative() on callsites, apparently\n    /* istanbul ignore next */\n    if (site.isNative()) {\n      res.native = true;\n    }\n\n    let typename;\n    try {\n      typename = site.getTypeName();\n    } catch (_) {\n    }\n\n    if (typename && typename !== 'Object' && typename !== '[object Object]') {\n      res.type = typename;\n    }\n\n    const fname = site.getFunctionName();\n    if (fname) {\n      res.function = fname;\n    }\n\n    const meth = site.getMethodName();\n    if (meth && fname !== meth) {\n      res.method = meth;\n    }\n\n    return res;\n  }\n\n  parseLine (line) {\n    const match = line && line.match(re);\n    if (!match) {\n      return null;\n    }\n\n    const ctor = match[1] === 'new';\n    let fname = match[2];\n    const evalOrigin = match[3];\n    const evalFile = match[4];\n    const evalLine = Number(match[5]);\n    const evalCol = Number(match[6]);\n    let file = match[7];\n    const lnum = match[8];\n    const col = match[9];\n    const native = match[10] === 'native';\n    const closeParen = match[11] === ')';\n    let method;\n\n    const res = {};\n\n    if (lnum) {\n      res.line = Number(lnum);\n    }\n\n    if (col) {\n      res.column = Number(col);\n    }\n\n    if (closeParen && file) {\n      // make sure parens are balanced\n      // if we have a file like \"asdf) [as foo] (xyz.js\", then odds are\n      // that the fname should be += \" (asdf) [as foo]\" and the file\n      // should be just \"xyz.js\"\n      // walk backwards from the end to find the last unbalanced (\n      let closes = 0;\n      for (let i = file.length - 1; i > 0; i--) {\n        if (file.charAt(i) === ')') {\n          closes++;\n        } else if (file.charAt(i) === '(' && file.charAt(i - 1) === ' ') {\n          closes--;\n          if (closes === -1 && file.charAt(i - 1) === ' ') {\n            const before = file.slice(0, i - 1);\n            const after = file.slice(i + 1);\n            file = after;\n            fname += ` (${before}`;\n            break;\n          }\n        }\n      }\n    }\n\n    if (fname) {\n      const methodMatch = fname.match(methodRe);\n      if (methodMatch) {\n        fname = methodMatch[1];\n        method = methodMatch[2];\n      }\n    }\n\n    setFile(res, file, this._cwd);\n\n    if (ctor) {\n      Object.defineProperty(res, 'constructor', {\n        value: true,\n        configurable: true,\n      });\n    }\n\n    if (evalOrigin) {\n      res.evalOrigin = evalOrigin;\n      res.evalLine = evalLine;\n      res.evalColumn = evalCol;\n      res.evalFile = evalFile && evalFile.replace(/\\\\/g, '/');\n    }\n\n    if (native) {\n      res.native = true;\n    }\n\n    if (fname) {\n      res.function = fname;\n    }\n\n    if (method && fname !== method) {\n      res.method = method;\n    }\n\n    return res;\n  }\n}\n\nfunction setFile (result, filename, cwd) {\n  if (filename) {\n    filename = filename.replace(/\\\\/g, '/');\n    if (filename.startsWith(`${cwd}/`)) {\n      filename = filename.slice(cwd.length + 1);\n    }\n\n    result.file = filename;\n  }\n}\n\nfunction ignoredPackagesRegExp(ignoredPackages) {\n  if (ignoredPackages.length === 0) {\n    return [];\n  }\n\n  const packages = ignoredPackages.map(mod => escapeStringRegexp(mod));\n\n  return new RegExp(`[\\/\\\\\\\\]node_modules[\\/\\\\\\\\](?:${packages.join('|')})[\\/\\\\\\\\][^:]+:\\\\d+:\\\\d+`)\n}\n\nconst re = new RegExp(\n  '^' +\n    // Sometimes we strip out the '    at' because it's noisy\n  '(?:\\\\s*at )?' +\n    // $1 = ctor if 'new'\n  '(?:(new) )?' +\n    // $2 = function name (can be literally anything)\n    // May contain method at the end as [as xyz]\n  '(?:(.*?) \\\\()?' +\n    // (eval at <anonymous> (file.js:1:1),\n    // $3 = eval origin\n    // $4:$5:$6 are eval file/line/col, but not normally reported\n  '(?:eval at ([^ ]+) \\\\((.+?):(\\\\d+):(\\\\d+)\\\\), )?' +\n    // file:line:col\n    // $7:$8:$9\n    // $10 = 'native' if native\n  '(?:(.+?):(\\\\d+):(\\\\d+)|(native))' +\n    // maybe close the paren, then end\n    // if $11 is ), then we only allow balanced parens in the filename\n    // any imbalance is placed on the fname.  This is a heuristic, and\n    // bound to be incorrect in some edge cases.  The bet is that\n    // having weird characters in method names is more common than\n    // having weird characters in filenames, which seems reasonable.\n  '(\\\\)?)$'\n);\n\nconst methodRe = /^(.*?) \\[as (.*?)\\]$/;\n\nmodule.exports = StackUtils;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}